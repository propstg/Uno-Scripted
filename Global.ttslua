require("changeHands")

--[[ Lua code. See documentation: https://api.tabletopsimulator.com/ --]]
--TableTop Simulator UNO Scripted
--Steam Workshop ID : 814121724

--Last UpdatedB By: propstg [GitHub]
--GitHub Pull Request #5 'Play with an additional deck'

--Date Last Updated: 12-27-2020
--TTS Version Created On: v12.4.3

debugging = false

--[[GUID Static References]]
startingDeck_GUID = "18c2e8"
playMatt_GUID = "f82f1f"
rotationMatt_GUID = "7b482f"
playDeckZone_GUID = "600b0b"
drawDeckZone_GUID = "45f602"

--[[String Variables That Are Used For Different Messages In The UI]]--
Waiting_For_Game_Start_Message="Waiting For The Host (%s) To Start The Game"
Waiting_For_Stacking_Message="Waiting For %s To Stack A Card, Or Draw Cards"
Waiting_For_Wild_Card_Message="Waiting For %s To Pick A Color"
Waiting_For_Trade_Message="Waiting For %s To Trade Their Cards With Another Player"
Stack_On_Another_Card="May Stack: %s"

--[[Table used to get quick references of the player colors in this game mode]]
PLAYERS_REF = {
    Player.Green,
    Player.Blue,
    Player.Purple,
    Player.Pink,
    Player.White,
    Player.Red,
    Player.Orange,
    Player.Yellow}
--[[Static reference of world locations in the world for where the player label token should be located for a given player]]
TOKENLOCATIONS_REF = {
    ["GREEN"]  = {   0,    1.5,    9},
    ["BLUE"]   = { 6.36,   1.5, 6.36},
    ["PURPLE"] = {   9,    1.5,    0},
    ["PINK"]   = { 6.36,   1.5,-6.36},
    ["WHITE"]  = {    0,   1.5,   -9},
    ["RED"]    = {-6.36,   1.5,-6.36},
    ["ORANGE"] = {   -9,   1.5,    0},
    ["YELLOW"] = {-6.36,   1.5, 6.36}}
--[[Static reference of rotations to keep the player label token facing outward for each given player]]
TOKENROTATIONS_REF = {
    ["GREEN"]  = {    0, 180,    0},
    ["BLUE"]   = {    0, 225,    0},
    ["PURPLE"] = {    0, 270,    0},
    ["PINK"]   = {    0, 315,    0},
    ["WHITE"]  = {    0, 360,    0},
    ["RED"]    = {    0,  45,    0},
    ["ORANGE"] = {    0,  90,    0},
    ["YELLOW"] = {    0, 135,    0}}
--[[Static table of attributes for spawning the draw buttons]]
DRAWBUTTONS_REF = {
    ["TOP"]      = { -2,  1.2,   2.3},
    ["BOTTOM"]   = { -2,  1.2,  -2.3},
    ["SCALE"]    = { 1.5, 1.5,   1.5},
    ["POSITION"] = { 0,   0.1,   0  },
    ["ROTATION"] = { 0,   0,     0  },
    ["WIDTH"]    = 1500,
    ["HEIGHT"]   = 700,
    ["FONTSIZE"] = 250}
YIELDSTATE = {
    ["STACK"] = "stacking",
    ["WILD"] = "wild",
    ["TRADE"] = "trade"}

drawButtons = {}                --Array used for the two 'Draw Card' buttons next to the draw deck
tokenLocations = {}             --Array used to keep reference for the current player token locations during runtime
tokenRotations = {}             --Array used to keep reference for the current player token rotations during runtime
seatedPlayers = {}              --Array used to keep reference for seated players during runtime

drawDeckZone = nil              --Object reference for the Scripting Zone where the Draw Deck is located
playDeckZone = nil              --Object reference for the Scripting Zone where the Play Deck is located
drawDeckObject = nil            --Object reference for the Game Object of the Draw Deck
playDeckObject = nil            --Object reference for the Game Object of the Play Deck
playMattObject = nil            --Object reference for the Game Object of the Play Matt
rotationMattObject = nil        --Object reference for the Game Object of the Rotation Matt
currentPlayerTokenObject = nil  --Object reference for the Game Object of the Current Player token

startingCardNumber = 7          --Code reference for the number of starting cards each player gets
gameStart = false               --Code reference for if a round of uno is started or waiting to start
gameRoom_Admin = nil            --Code reference for the host player
playerOne_Index = nil           --Code reference for the array index of the player that is 'player one'
currentPlayer = nil             --Code reference for the current player
currentPlayer_Index = nil       --Code reference for the array index of the current player
currentPlayer_Label = nil       --Code reference for the Steam name of the current player
nextPlayer = nil                --Code reference for the next player
nextPlayer_Index = nil          --Code reference for the array index of the next player
lastCard_Name = nil             --Code reference for the Name of the last played card
lastCard_Desc = nil             --Code reference for the Description of the last played card
clockwisePlay = true            --Code reference for the direction of turn order
stackingCounter = 0             --Code reference for how many cards will be drawn when stacking stops
playerIsStacking = false           --Code reference for if the current player is stacking or not
cardDrawn = false               --Code reference for if a player has drawn a card this turn
passButtonShown = false         --Code reference for if the 'Pass Turn' button is shown or not
winCondition = false            --Code reference for when a player meets the win condition
decksFlipped = false            --Code reference for if the decks have been flipped when moving the play deck into the draw deck
gameloopCoroutine = nil         --Code reference for the our 'GameLoop' coroutine
yieldState = nil                --Code reference for the yield state of our 'GameLoop' coroutine

show_UNO = false
uno_Called = false              --Code reference for if a player has clicked the button and called UNO
uno_Button_Visible = false      --Code reference for if the Call UNO button is visible
color_Has_Uno = nil             --Code reference for what player is currently calling UNO
colorsWithUNO = {}              --Code reference for all players that currently have UNO

UI_DrawOneCard = true           --UI Toggle enable / disable only drawing one card
UI_AllowTurnPassing = false      --UI toggle to enable / disable passing your turn with out playing a card
UI_ShowMainMenu = false         --UI toggle to show or hide the main menu
UI_EnableStacking = false       --UI toggle to enable / disable 'all stacking' rules
UI_EnableD2Stacking = false     --UI toggle to enable / disable 'only stack +2' rules
UI_EnableD4Stacking = false     --UI Toggle to enable / disable 'only stack +4' rules
UI_EnableReverseSkipStacking = false
UI_EnableSevenZero = false      --UI toggle to enable / disable 7-0 rules
UI_EnableCallingUno = true      --UI toggle to enable / disable calling uno
UI_EnableAdditionalDeck = false --UI toggle to enable / disable playing with an additional deck

---------------------------------------------------------------------------------------------------------------------------
--EVENT FUNCTIONS
---------------------------------------------------------------------------------------------------------------------------

function onUpdate()

end

--[[ The onLoad event is called after the game save finishes loading. --]]
function onLoad()
    --Set references to the static objects in our game
    drawDeckZone = getObjectFromGUID(drawDeckZone_GUID)
    playDeckZone = getObjectFromGUID(playDeckZone_GUID)
    drawDeckObject = getObjectFromGUID(startingDeck_GUID)
    playMattObject = getObjectFromGUID(playMatt_GUID)
    rotationMattObject = getObjectFromGUID(rotationMatt_GUID)
    --Reset the color tint to the PlayMat and Rotation Mat, just to be safe
    playMattObject.setColorTint({1,1,1})
    rotationMattObject.setColorTint({1,1,1})
    rotationMattObject.setRotation({0,0,180})
    --Disable interaction with Key objects to avoid players messing things up
    if(debugging == false)
    then
      drawDeckObject.interactable = false
      playMattObject.interactable = false
      rotationMattObject.interactable = false
      rotationMattObject.setLock(true)
    end
    --Update our reference table to the players that are seated
    UpdatePlayerTable()
    --Reset any key variables, just to be safe
    playerIsStacking = false

    --Init certain UI elements
    --Because we manipulate the "visibilty" tag on these elements later, we need to keep them active, but hide them
    UI.hide("StackingCardPanel")
    UI.hide("WildCardPanel")
    UI.hide("PassButtonPanel")
    UI.hide("UNO_Button")
    UI.hide("UNO_Penalty_Button")
    --Init the Message Panel and Starting Player Button
    UI.setAttribute("MessagePanelText", "Text", (Waiting_For_Game_Start_Message):format(gameRoom_Admin.steam_name))
    --We default the Player One button to the Game Admin just for simplicity
    UI.setAttribute("playerOneButton", "Text", gameRoom_Admin.steam_name)
    UI.setAttribute("playerOneButton", "Color", gameRoom_Admin.color)
    
end--Function onLoad END\
--[[This function is called anytime a player enters or leaves a color seat]]
function onPlayerChangedColor(player_color)
    if gameStart == true
    then
        if player_color ~= "Grey"
        then
            ClearHands(false)

            if player_color ~= "Black"
            then
                if #Player[player_color].getHandObjects() == 0
                then
                    DealCardsToColor(7, player_color)
                    
                end
            end
        end
    end
    UpdatePlayerTable()
end--Function onPlayerChangedColor END
--[[This function is primarily used to make sure players are not throwing cards out of their hands]]
function onObjectDrop(player_color,dropped_object)

    local cardDropped = true
    --First, we only care if the object a player is dropping is a card
    if dropped_object.tag == 'Card'
    then
        --We check the "Owner" of the dropped card, and compare it to the Player that dropped it
        if dropped_object.getVar("Owner").color == Player[player_color].color
        then
            --Using Wait.time() and an in-line function, we can execute the following code after a certain amount of time
            Wait.time(
            function ()
                --First we get a reference to if the card being dropped is being played
                local inPlay = dropped_object.getVar("CardInPlay")
                --We also get a reference to the player color for simplicity
                local _player = Player[player_color]

                --We check if the card being dropped is NOT being played
                if inPlay == false
                then
                    --What we do here is loop through all of the objects that are now in the players hands, to see if the card being dropped
                    --is being dropped into their hand, in which case no further action is needed
                    for i = 1 , #Player[player_color].getHandObjects(), 1
                    do--Loop through all the objects the player has picked up
                        if Player[player_color].getHandObjects()[i] == dropped_object
                        then
                            cardDropped = false
                        end
                    end
                    --At this point, if the card being dropped is NOT being played, and is NOT being dropped into their hand, we will assume
                    --The card is being dropped out in the open, and we should return the card to their hand
                    if cardDropped == true
                    then
                        dropped_object.setPosition({_player.getPlayerHand()['pos_x'],_player.getPlayerHand()['pos_y'],_player.getPlayerHand()['pos_z']})
                        dropped_object.setRotation({_player.getPlayerHand()['rot_x'],_player.getPlayerHand()['rot_y']+180,_player.getPlayerHand()['rot_z']})
                        broadcastToColor("Please only leave your cards in the play zone", player_color, getColorValueFromPlayer(player_color))
                    end
                end
            end,--End In-Line Function
            0.2)--This function will execute 0.2 seconds after a card is dropped
        end
    end
end--Function onObjectDrop END
--[[This is mostly used to stop players from trying to play more than one card at a time]]
function onObjectPickUp(player_color, picked_up_object)
    --If the card being picked up does not belong to the player picking it up, or if the player is NOT the Game Master (Black seat) we need to force them to drop it
    if picked_up_object.getVar("Owner").color ~= Player[player_color].color and player_color ~= "Black" and debugging == false
    then
        picked_up_object.drop()
        broadcastToColor("Do Not Take Other Players Cards", player_color, getColorValueFromPlayer(player_color))
    end
end--Function onObjectPickUp END

function handleGameLoopStackingState(enter_object)
    --During Stacking, we check if the card being played is the same face-card as the last played card.
    if enter_object.getName() == lastCard_Name then
        CheckCard(enter_object)

    --If we are allowing ALL stacking, a +2 or a +4 card may be played to stack, regardless of what the lastCard is.
    elseif UI_EnableStacking == true then
        if enter_object.getName() == "+2" or enter_object.getName() == "+4" or enter_object.getName() == "reverse" or enter_object.getName() == "skip" then
            CheckCard(enter_object)
        else
            RejectCard(enter_object,"You Must Play A Card That Stacks, Or Draw Cards")
        end

    --If we are NOT allowing ALL stacking, the entering card should have matched face
    else
        RejectCard(enter_object,"You Must Play A Card That Stacks, Or Draw Cards")
    end
end

--[[This handles the logic of when a player tries to put a card into play]]
function onObjectEnterScriptingZone(zone, enter_object)

    if enter_object.held_by_color ~= "Black"
    then--The game master (player color black) is exempt from a lot of game rules
        if winCondition == false
        then--is the win condition met
            if enter_object.getGUID() ~= currentPlayerTokenObject.getGUID()
            then--We ignore the Current Player Token from any scripting zones
                if zone.getGUID() == playDeckZone_GUID
                then--If the calling zone if the playDeck zone
                    if enter_object.tag == 'Card'
                    then--is the entering object a card
                        if enter_object.held_by_color ~= nil
                        then--is the entering card being held by a player
                            if currentPlayer ~= nil
                            then--is the currentPlayer value is not empty
                                if enter_object.held_by_color == currentPlayer.color
                                then--is the player holding the card the current player
                                    if #Player[enter_object.held_by_color].getHoldingObjects() == 1
                                    then--is the player holding the card only holding one card
                                        if gameloopCoroutine ~= nil
                                        then--Check if the game loop is empty. Empty means it's the first turn and some logic checks can be assumed
                                            if coroutine.status(gameloopCoroutine) == "suspended"
                                            then--if the game loop is suspended, it is waiting for some sort of player response
                                                if yieldState == YIELDSTATE.STACK then--Our game loop is waiting for a player to stack cards
                                                    handleGameLoopStackingState(enter_object)
                                                elseif yieldState == YIELDSTATE.WILD
                                                then--Our game loop is waiting for a player to choose a wild color
                                                    RejectCard(enter_object, "You Must Pick A Wild Color")

                                                elseif yieldState == YIELDSTATE.TRADE
                                                then--our game loop is waiting for a player to trade cards
                                                    RejectCard(enter_object, "You Must Decide Who To Trade Cards With")
                                                end
                                            else
                                                CheckCard(enter_object)
                                            end
                                        else--the game loop is empty - assuming it is the first turn
                                            CheckCard(enter_object)
                                        end
                                    else--The player holding the card is also holding more than one card
                                        RejectCard(enter_object, "You May Only Play One Card At A Time")
                                    end
                                else--The player holding the object is not the Current Player
                                    RejectCard(enter_object,"It Is Not Your Turn Now")
                                end
                            end
                        end
                    else--The object entering our PlayZone is NOT a card, but there are still some special cases we need to check for
                        if enter_object.tag ~= "Deck"
                        then
                            if enter_object ~= currentPlayerTokenObject
                            then
                                --The Deck and the Player Token will sometimes trigger out Play Zone, but we don't want to apply any logic to them. Anything else should not be allowed to enter the zone though
                                RejectObject(enter_object)
                            end
                        end
                    end
                end
            end
        end
    end
end--Funciton onObjectEnterScriptingZone END

---------------------------------------------------------------------------------------------------------------------------
--GAME LOGIC FUNCTIONS
---------------------------------------------------------------------------------------------------------------------------

--[[This function handles anything that needs taken care of at the start of a round of UNO]]
function InitGame()


    currentPlayer = seatedPlayers[playerOne_Index]
    currentPlayer_Index = playerOne_Index
    --Hide the UI elements that are only used at the start of a game
    UI.setAttribute("MainMenuContainer", "active", "False")
    UI.setAttribute("MessagePanel", "active", "False")
    --UI.setAttribute("HideMenuButton", "active", "False")
    
    
    --Tell the players what order they are in
    ListPlayers()
    UpdatePlayerLabel()
    
    --Create Objects & Buttons for drawing from the deck
    drawButtons[0] = spawnObject({
        type              = "PiecePack_Suns",
        position          = DRAWBUTTONS_REF.BOTTOM,
        rotation          = {0,180,0},
        scale             = {0.5,0.5,0.5},
        callback_fucntion = "dummyFunction",
        sound             = false})
    drawButtons[0].createButton({
        click_function = "DrawCard",
        function_owner = Global,
        label          = "Draw Card",
        position       = DRAWBUTTONS_REF.POSITION,
        rotation       = DRAWBUTTONS_REF.ROTATION,
        scale          = DRAWBUTTONS_REF.SCALE,
        width          = DRAWBUTTONS_REF.WIDTH,
        height         = DRAWBUTTONS_REF.HEIGHT,
        font_size      = DRAWBUTTONS_REF.FONTSIZE,
        color          = color(1, 1, 1, 1),
        font_color     = color(0, 0, 0, 1),
        tooltip        = "Draw a card from the Draw Deck"})
    drawButtons[1] = spawnObject({
        type              = "PiecePack_Suns",
        position          = DRAWBUTTONS_REF.TOP,
        rotation          = {0,0,0},
        scale             = {0.5,0.5,0.5},
        callback_fucntion = "dummyFunction",
        sound             = false})
    drawButtons[1].createButton({
        click_function = "DrawCard",
        function_owner = Global,
        label          = "Draw Card",
        position       = DRAWBUTTONS_REF.POSITION,
        rotation       = DRAWBUTTONS_REF.ROTATION,
        scale          = DRAWBUTTONS_REF.SCALE,
        width          = DRAWBUTTONS_REF.WIDTH,
        height         = DRAWBUTTONS_REF.HEIGHT,
        font_size      = DRAWBUTTONS_REF.FONTSIZE,
        color          = color(1, 1, 1, 1),
        font_color     = color(0, 0, 0, 1),
        tooltip        = "Draw a card from the Draw Deck"})

    drawButtons[0].setLock(true)
    drawButtons[1].setLock(true)
    AddAdditionalDeckToDrawDeckIfNeeded()
    --Shuffle the deck
    drawDeckObject.shuffle()

    --Seed the first card
    drawDeckCards = drawDeckObject.getObjects()
    local counter = 0

    --We iterate through the draw pile until we find a card that is NOT a wild, to use as our starting play card
    repeat
        counter = counter + 1
    until drawDeckCards[counter].description ~= "WILD"

    playDeckObject = drawDeckObject.takeObject({
        position = { playDeckZone.getPosition()['x'] , 1.5 , playDeckZone.getPosition()['z'] },
        rotation = { 0,180,0},
        index = counter-1,
        smooth =  false })

    lastCard_Name = playDeckObject.getName()
    lastCard_Desc = playDeckObject.getDescription()
    playMattObject.setColorTint(getColorValueFromCard(lastCard_Desc))
    rotationMattObject.setColorTint(getColorValueFromCard(lastCard_Desc))
    rotationMattObject.setRotation({0,0,180})
    --Deal 7 cards to each seated player
    for i,player in ipairs(seatedPlayers)
    do
        DealCardsToColor(startingCardNumber, player.color)
    end

    Wait.time(
        function () UpdateDeckObjects() end,
        0.5)


    --tell the game logic that the game has started
    gameStart = true
end--Function InitGame END

function AddAdditionalDeckToDrawDeckIfNeeded()
    if UI_EnableAdditionalDeck then
        drawDeckObject.clone({position = drawDeckObject.getPosition()})
    end
end

--This function gives me nightmares
function Reset_Game()

    --First we hide and reset any UI elements that are used during gameplay
    UI.hide("StackingCardPanel")
    UI.hide("WildCardPanel")
    UI.hide("PassButtonPanel")
    UI.hide("UNO_Button")
    UI.setAttribute("PlayerLabel", "active", "false")
    UI.setAttribute("playerOneButton", "Text", currentPlayer.steam_name)
    UI.setAttribute("playerOneButton", "Color", currentPlayer.color)

    UpdatePlayerTable()--Update our reference to the seated players
    ToggleDrawButtons(false)--Hide our draw card buttons
    Wait.time(
      function()
        ClearHands(true)--clear out the cards out of players' hands, ignoring if a player is seated there
      end,
    1)

    --Reset our UNO tracking variables
    uno_Called = false
    uno_Button_Visible = false
    color_Has_Uno = nil

    --This function will reset the play and draw decks after 2 seconds
    Wait.time(
        function ()
            UpdateDeckObjects()
            playDeckObject.interactable = true
            playDeckObject.setRotation({180,180,0})
            playDeckObject.setPosition({drawDeckZone.getPosition()['x'] , 3 , drawDeckZone.getPosition()['z']})
            --playDeckObject = nil
            Wait.time(function () drawDeckObject.shuffle() end, 1)
            end,
        2)
    --This function will reset any key variables after 3 seconds
    Wait.time(
        function ()
            gameStart = false
            winCondition = false
            playerOne_Index = currentPlayer_Index
            lastCard_Name = nil
            lastCard_Desc = nil
            gameloopCoroutine = nil
            playerIsStacking = false
        end,
        3)
    --This function will show the Show the Start Game UI elements after 4 seconds
    Wait.time(
        function ()
            UI.setAttribute("StartGameMenu", "active", "true")
            UI.setAttribute("MessagePanel", "active", "true")
            UI.setAttribute("MainMenuContainer", "active", "true")
            UI.show("MessagePanel")

            UI.setAttribute("MessagePanelText", "Text", (Waiting_For_Game_Start_Message):format(gameRoom_Admin.steam_name))
            UI.setAttribute("HideMenuButton", "visibility", "Host")
            UI.setAttribute("StartGameMenu", "visibility", "Host")
        end,
        4)
    --Reset the color tint of our Play Mat and Rotation Mat
    playMattObject.setColorTint({1,1,1})
    rotationMattObject.setColorTint({1,1,1})
    rotationMattObject.setRotation({0,0,180})
end--Function Reset_Game END

--[[This function is called after we've determined that a card is allowed to be put into play. This makes sure that the card played is a playable card]]
function CheckCard(currentCard)
    -- We check ifthe lastCard_Name is empty(nil), meaning this is the first card in the pile
    if lastCard_Name == nil then
        PlayCard(currentCard)
    -- Otherwise, we need to check our current card against the last card
    -- Check for wild cards
    elseif currentCard.getDescription() == "WILD" then
        PlayCard(currentCard)
    --check if the faces match
    elseif currentCard.getName() == lastCard_Name then
        PlayCard(currentCard)
    --check if the color matches
    elseif currentCard.getDescription() == lastCard_Desc then
        PlayCard(currentCard)
    --The card isn't wild and doesn't match face or color
    else
        RejectCard(currentCard,"This Card Cannot Be Played")
    end
end--Function CheckCard END

--[[This function is used to return an invalid card to the players hand]]
function RejectCard(currentCard, game_message)

    --Grab a quick reference to the player that is holding the card
    local _player = Player[currentCard.held_by_color]
    if game_message ~= ""
    then--If the game_message is *not* empty, broacast it to the player
        broadcastToColor(game_message, _player.color ,getColorValueFromPlayer(_player.color))
    end
    --send the currentCard back to the player's hand
    currentCard.setPositionSmooth({_player.getPlayerHand()['pos_x'],_player.getPlayerHand()['pos_y'],_player.getPlayerHand()['pos_z']})

end--Function RejectCard END
--[[The function is mostly used to stop non-card objects from entering the game zones]]
function RejectObject(obj)

    if obj.held_by_color ~= nil
    then
        broadcastToColor("This object does not belong in the playing card area", obj.held_by_color, getColorValueFromPlayer(obj.held_by_color))
    else
        broadcastToAll("An invalid object entered the playing card area", getColorValueFromPlayer(PLAYERS_REF.WHITE))
    end

    local velocity = obj.getVelocity()
    obj.translate({
        ClampValue( -(math.floor(velocity.x*2)+5),-8,8),
        3,
        ClampValue( -(math.floor(velocity.z*2)+5),-8,8)})

end--Function RejectObject
--[[This function handles a little bit of logic when a card is being put into play, before we dive into our main Game Loop]]
function PlayCard(cardObj)

    if uno_Button_Visible == true
    then
        HideUNO()
    end

    cardObj.setRotationSmooth({0,180,0}, false, true)
    local FixedPos = playDeckZone.getPosition()
    cardObj.setPositionSmooth({FixedPos.x,3,FixedPos.z}, false, true)

    if #currentPlayer.getHandObjects() == 1
    then
        show_UNO = true
        --PlayerHasUNO(currentPlayer.color)
    end

    if #currentPlayer.getHandObjects() == 0 and winCondition == false
    then--If a player has no more cards in their hand after a card is played, a win condition has been met
        broadcastToAll(currentPlayer.steam_name .. " Has Played Their Last Card & Won The Round", getColorValueFromPlayer(currentPlayer.color))
        winCondition = true
        Reset_Game()
    end

    --we set the card's "CardInPlay" variable to true now that it has entered the play deck
    cardObj.setVar("CardInPlay", true)
    if winCondition == false
    then--If the Win Condition has not yet been met, we can continue with our game play logic
        if gameloopCoroutine ~= nil
        then--if our Game Loop is not empty, then we need to resume it. This should only be the case for a wild card, or draw card, and our game logic up to this point has made sure the correct conditions have been met, and we can safely resume our Game Loop
            if coroutine.status(gameloopCoroutine) == "suspended"
            then
                coroutine.resume(gameloopCoroutine)
            end
        end
        --Update our references to the last card that has been played
        lastCard_Name = cardObj.getName()
        lastCard_Desc = cardObj.getDescription()

        if lastCard_Desc ~= "WILD"
        then--So long as the last card played is NOT a wild card, we should update our play matts to the correct color
            playMattObject.setColorTint(getColorValueFromCard(lastCard_Desc))
            rotationMattObject.setColorTint(getColorValueFromCard(lastCard_Desc))
        end

        --Start our Game Loop
        gameloopCoroutine = coroutine.create(GameLoop)
        coroutine.resume(gameloopCoroutine)

    end

end--Function PlayCard END
--[[This function is called when a Player plays a card and only has one more card left in there hand]]
function PlayerHasUNO(color)

    if(UI_EnableCallingUno == true)
    then
        --We set the UNO button to a random position along the X access, to avoid other players from 'camping' the button location
        math.randomseed(os.time())
        UI.setAttribute("UNO_Button", "OffsetXY", ( math.random(-350,350).." 250") )

        --set the appropriate 'tracking' variables
        uno_Called = false
        uno_Button_Visible = true
        color_Has_Uno = color

        --We set the UNO button color to the player color with UNO to help identify
        UI.setAttribute("UNO_Button", "color", color )
        UI.show("UNO_Button")
    else
        colorsWithUNO[#colorsWithUNO+1] = color
        UI.setAttribute("UNO_Penalty_Button","visibility",getVisibilityTargerts(colorsWithUNO))
        UI.Show("UNO_Penalty_Button")
        uno_Button_Visible = true
    end

end--Function PlayerHasUNO END
--[[This function is called when someone presses the UNO button, or if play proceeds without someone calling the UNO button]]
function HideUNO()
    --Hide the UNO button so it can no longer be clicked
    UI.hide("UNO_Button")
    UI.hide("UNO_Penalty_Button")
    uno_Button_Visible = false
    show_UNO = false
end--Function HideUNO END
--[[Helper Function that can be given a Player Color and a number, to deal that many cards to that Player]]
function DealCardsToColor(count,color)
    for i=1, count
    do
        local dealtCard
        local _player = Player[color]
        --drawDeckObject.deal(1, color)
        dealtCard = drawDeckObject.takeObject({
            position = {_player.getPlayerHand()['pos_x'],_player.getPlayerHand()['pos_y'],_player.getPlayerHand()['pos_z']},
            rotation = {_player.getPlayerHand()['rot_x'],_player.getPlayerHand()['rot_y']+180,0},
            index = 1,
            smooth = false})

        dealtCard.setVar("Owner", _player)
        dealtCard.setVar("CardInPlay", false)
    end
end--Function DealCards END
--[[This function will clear out the cards a hand zone. Normally, this function will only clear hands that don't have a seated player, but can clear all hands if given a condition]]
function ClearHands(ignoreSeated)

    for i=1,#seatedPlayers
    do
        for j=1, #seatedPlayers[i].getHoldingObjects()
        do
            if seatedPlayers[i].getHoldingObjects()[j].tag=='Card'
            then
                seatedPlayers[i].getHoldingObjects()[j].setPositionSmooth(seatedPlayers[i].getHandTransform()['position'], false, true)
            end
        end
    end
    Wait.frames(
        function()
            for i, player in ipairs(PLAYERS_REF)
            do
                if player.seated == false or ignoreSeated == true
                then
                    if #player.getHandObjects() > 0
                    then
                        deckPosition = { drawDeckObject.getPosition()['x'] , drawDeckObject.getPosition()['y'] + 0.5 , drawDeckObject.getPosition()['z'] }
                        deckRotation = drawDeckObject.getRotation()
                        for i, card in ipairs(player.getHandObjects())
                        do
                            card.setRotation(deckRotation)
                            card.setPosition(deckPosition)
                        end
                        drawDeckObject.shuffle()
                    end
                end
            end
        end, 30)
end--Function ClearHands END


function RotateHands()
    local startingHands = {}
    for i = 1, #seatedPlayers do
        startingHands[i] = seatedPlayers[i].getHandObjects()
        AddHeldCardsToHand(startingHands[i], i)
    end

    for i = 1, #startingHands do
        local nextIndex = getNextSeatedPlayerIndex(i)
        for j = 1, #startingHands[i] do
            startingHands[i][j].setVar("Owner", seatedPlayers[nextIndex])
            startingHands[i][j].setPosition(seatedPlayers[nextIndex].getHandTransform()['position'] )
            startingHands[i][j].setRotation({seatedPlayers[nextIndex].getPlayerHand()['rot_x'], seatedPlayers[nextIndex].getPlayerHand()['rot_y']+180,0})
        end
    end

    Wait.frames(function()
        for i = 1, #seatedPlayers do
            for j = 1, #seatedPlayers[i].getHandObjects() do
                if seatedPlayers[i].getHandObjects()[j].getVar("Owner").color ~= seatedPlayers[i].color then
                    _player = Player[seatedPlayers[i].getHandObjects()[j].getVar("Owner").color]
                    seatedPlayers[i].getHandObjects()[j].setPosition(_player.getHandTransform()["position"])
                    seatedPlayers[i].getHandObjects()[j].setRotation({_player.getPlayerHand()['rot_x'],_player.getPlayerHand()['rot_y']+180,0})
                end
            end
        end
    end, 20)
end

function SwapHands(sendingPlayerIndex, receivingPlayerIndex)
    local sendersHand = seatedPlayers[sendingPlayerIndex].getHandObjects()    
    local receiversHand = seatedPlayers[receivingPlayerIndex].getHandObjects()

    AddHeldCardsToHand(receiversHand, receivingPlayerIndex)
    AddHeldCardsToHand(sendersHand, sendingPlayerIndex)

    for j = 1, #sendersHand do
        sendersHand[j].setVar("Owner", seatedPlayers[receivingPlayerIndex])
        sendersHand[j].setPosition(seatedPlayers[receivingPlayerIndex].getHandTransform()['position'])
        sendersHand[j].setRotation({seatedPlayers[receivingPlayerIndex].getPlayerHand()['rot_x'],seatedPlayers[receivingPlayerIndex].getPlayerHand()['rot_y']+180,0})
    end

    for j = 1, #receiversHand do
        receiversHand[j].setVar("Owner", seatedPlayers[sendingPlayerIndex])
        receiversHand[j].setPosition(seatedPlayers[sendingPlayerIndex].getHandTransform()['position'])
        receiversHand[j].setRotation({seatedPlayers[sendingPlayerIndex].getPlayerHand()['rot_x'],seatedPlayers[sendingPlayerIndex].getPlayerHand()['rot_y']+180,0})
    end

    Wait.frames(function()
        for i=1,#seatedPlayers do
            for j=1,#seatedPlayers[i].getHandObjects() do
                if seatedPlayers[i].getHandObjects()[j].getVar("Owner").color ~= seatedPlayers[i].color then
                    _player = Player[seatedPlayers[i].getHandObjects()[j].getVar("Owner").color]
                    seatedPlayers[i].getHandObjects()[j].setPosition(_player.getHandTransform()["position"])
                    seatedPlayers[i].getHandObjects()[j].setRotation({_player.getPlayerHand()['rot_x'],_player.getPlayerHand()['rot_y']+180,0})
                end
            end
        end
    end, 20)
end

function AddHeldCardsToHand(handToAddTo, playerIndex)
    for i = 1, #seatedPlayers[playerIndex].getHoldingObjects() do
        if seatedPlayers[playerIndex].getHoldingObjects()[i].tag == 'Card' then
            handToAddTo[#handToAddTo + i] = seatedPlayers[playerIndex].getHoldingObjects()[i]
        end
    end
end

--[[This function is responsible for update both the Current Player token that moves around the board, and the Current Player UI element]]
function UpdatePlayerLabel(token)

    local tokenLocation
    local tokenLabel
    local tokenColor
    local tokenRotation

    if currentPlayer ~= nil
    then
        tokenLocation = getTokenLocation(currentPlayer.color)
        tokenLabel = ("Current Player:\n%s"):format(currentPlayer.steam_name)
        tokenColor = currentPlayer.color
        tokenRotation = getTokenRotation(currentPlayer.color)
    else
        tokenLocation = getTokenLocation(Player.Black.color)
        tokenLabel = "No Player One"
        tokenColor = Player.Black.color
        tokenRotation = getTokenRotation(Player.Black.color)
    end

    if currentPlayerTokenObject == nil
    then
        currentPlayerTokenObject = spawnObject({
        type              = "PiecePack_Suns",
        position          = tokenLocation,
        rotation          = {0,0,0},
        scale             = {0.8,0.8,0.8},
        callback_fucntion = "dummyFunction",
        sound             = false})
    end


    currentPlayerTokenObject.interactable = false
    currentPlayerTokenObject.use_gravity = false
    currentPlayerTokenObject.setColorTint(getColorValueFromPlayer(tokenColor))
    currentPlayerTokenObject.setPositionSmooth(tokenLocation,false,false)
    currentPlayerTokenObject.setRotation(tokenRotation)

    UI.setAttribute("PlayerLabel", "active", "True")
    UI.setAttribute("PlayerLabel", "text", tokenLabel)

    if currentPlayerTokenObject.UI.getXml() ~= ""
    then
        currentPlayerTokenObject.UI.setAttribute("PlayerLabel", "text", tokenLabel)
    else
        currentPlayerTokenObject.UI.setXmlTable(
        {
            {
                tag="HorizontalLayout",
                attributes=
                {
                    height=600,
                    width=1000,
                    position="0 0 -10",
                    color="rgba(0,0,0,0)",
                },
                children=
                {
                    {
                        tag="Text",
                        attributes=
                        {
                            id="PlayerLabel",
                            text= tokenLabel,
                            fontSize="130",
                            color= "white",
                            outline="black",
                            outlineSize="4 4"
                        },
                    },
                }
            }
        })
    end
end--Function UpdatePlayerLabel END
--[[This function broacasts what players are in what order, starting with player 1]]
function ListPlayers()

    --First we make sure to update our reference of seated players
    UpdatePlayerTable()

    local counter = 0

    for i = 1,#seatedPlayers,1
    do
        if currentPlayer~= nil
        then
            broadcastToAll(seatedPlayers[(currentPlayer_Index + counter)].steam_name .. " is player " .. i, getColorValueFromPlayer(seatedPlayers[(currentPlayer_Index+counter)].color))
            if (currentPlayer_Index + counter + 1) <= #seatedPlayers
            then
                counter = counter + 1
            else
                counter = (-currentPlayer_Index)+1
            end
        end
    end
end--Function ListPlayers END
--[[This function is called when one of the Draw Card buttons are clicked]]
function DrawCard(obj,color)

    if winCondition == false
    then
        if color ~= nil and color ~= "Black"
        then
            if color == currentPlayer.color
            then
                if yieldState == YIELDSTATE.STACK
                then
                    broadcastToColor("You Can Not Draw A Card At This Time",color, getColorValueFromPlayer(color))
                elseif yieldState == YIELDSTATE.WILD
                then
                    broadcastToColor("You Can Not Draw A Card At This Time", color, getColorValueFromPlayer(color))
                else
                    if UI_DrawOneCard == true
                    then
                            if cardDrawn == true
                            then
                                broadcastToColor("You May Only Draw One Card per Turn. Play A Card, or Pass", currentPlayer.color,getColorValueFromPlayer(currentPlayer.color))
                                return
                            else
                                DealCardsToColor(1,color)
                                HideUNO()
                                UpdateDeckObjects()
                                cardDrawn = true

                                if passButtonShown == false
                                then
                                    UI.show("PassButtonPanel")
                                    passButtonShown = true
                                    UI.setAttribute("PassButtonPanel","visbility", currentPlayer.color)
                                end
                            end
                    else
                            if UI_AllowTurnPassing == true
                            then
                                if passButtonShown == false
                                then
                                    UI.show("PassButtonPanel")
                                    passButtonShown = true
                                    UI.setAttribute("PassButtonPanel","visbility", currentPlayer.color)
                                end
                            end
                            DealCardsToColor(1,color)
                            HideUNO()
                            UpdateDeckObjects()
                    end
                end
            end
        end
    end
end--Function DrawCard END
--updates the reference to 'gameRoom_Admin' 'seatedPlayers' 'tokenLocations' & 'tokenRotations' based on the players seated at the table
function UpdatePlayerTable()
    local counter = 1

    --Empty our reference tables
    seatedPlayers = {}
    tokenLocations = {}
    tokenRotations = {}

    if Player.Black.seated
    then
        if Player.Black.admin
        then
        gameRoom_Admin = Player.Black
        end
    end

    for i, _player in ipairs(PLAYERS_REF)
    do--Go through our static PLAYERS_REF table

        if _player.admin
        then--Check if the player is the host or a promoted player
            gameRoom_Admin=_player
            if currentPlayer == nil
            then--For simplicity, if the currentPlayer is not set, we set it to the admin
            currentPlayer = _player
            currentPlayer_Index = counter
            playerOne_Index = counter
            end
        end
        if _player.seated
        then--If a given player is seated
            seatedPlayers[counter] = _player--add that player to our reference table, and update our tokenLocations table
            tokenLocations[counter] = getTokenLocation(i)
            counter = counter + 1
        end
    end

    if currentPlayer ~= nil
    then
        if #seatedPlayers > 0
        then
            if currentPlayer.seated == false
            then
                currentPlayer = seatedPlayers[#seatedPlayers]
                currentPlayer_Index = #seatedPlayers
            end
        end
    end

end--Function UpdatePlayerTable END
--This function keeps our references to the draw and play deck objects up to date, and will reset the play deck when the draw deck becomes too small
function UpdateDeckObjects()

    playZoneObjects = playDeckZone.getObjects()
    drawDeckCards = drawDeckObject.getObjects()


    if decksFlipped == true
    then
        --Shuffle Deck twice because why not?
        drawDeckObject.shuffle()
        drawDeckObject.shuffle()
        decksFlipped = false
    end

    for i, v in pairs(playZoneObjects)
    do
        if v.tag == "Deck"
        then
            playDeckObject = v
            playDeckObject.interactable = false
        end
    end

    --Re-Establish the deck objects interactable status]
    if drawDeckObject then
        if debugging == false then
            drawDeckObject.interactable = false
        end
    end
    if playDeckObject then
        if debugging == false then
            playDeckObject.interactable = false
        end
    end

    if #drawDeckCards < 18
    then
        playDeckObject.interactable = true
        playDeckObject.takeObject({
        position = { playDeckZone.getPosition()['x'] , 2.8 , playDeckZone.getPosition()['z'] },
        index = #playDeckObject.getObjects()-1,
        smooth = true })
        playDeckObject.flip()
        playDeckObject.setPositionSmooth({drawDeckObject.getPosition()['x'],drawDeckObject.getPosition()['y']+2,drawDeckObject.getPosition()['z']}, false, true)
        decksFlipped = true

        Wait.time(
            function () UpdateDeckObjects() end,
            1.0)
    end
end--Function UpdateDeckObjects END
--[[Calculates the next currentPlayer & currentPlayer_Index]]
function EndPlayerTurn()

    if clockwisePlay == true
    then
        if currentPlayer_Index + 1 > #seatedPlayers
        then
            currentPlayer_Index = 1
        else
            currentPlayer_Index = currentPlayer_Index + 1
        end
    else
        if currentPlayer_Index - 1 <= 0
        then
            currentPlayer_Index = #seatedPlayers
        else
            currentPlayer_Index = currentPlayer_Index - 1
        end
    end

    if clockwisePlay == true
    then
        if currentPlayer_Index + 1 > #seatedPlayers
        then
            nextPlayer_Index = 1
        else
            nextPlayer_Index = currentPlayer_Index + 1
        end
    else
        if currentPlayer_Index - 1 <= 0
        then
            nextPlayer_Index = #seatedPlayers
        else
            nextPlayer_Index = currentPlayer_Index - 1
        end
    end
    currentPlayer = seatedPlayers[currentPlayer_Index]
    nextPlayer = seatedPlayers[nextPlayer_Index]
    cardDrawn = false



    UpdatePlayerLabel()

    UI.hide("PassButtonPanel")
    passButtonShown = false

    Wait.time(
        function ()
            UpdateDeckObjects()
        end,
        0.75)

end--Function EndPlayerTurn END
--[[This is the function that does most of the logic for special cards]]

function GameLoop()
    --Check if the card played was a reverse.
    if lastCard_Name == "reverse" then
        clockwisePlay = not clockwisePlay
        rotationMattObject.setLock(false)

        if clockwisePlay == false then
            rotationMattObject.setRotation({0,0,0})
        else
            rotationMattObject.setRotation({0,0,180})
        end

        if #seatedPlayers == 2 then
            EndPlayerTurn()
        end
        rotationMattObject.setLock(true)
        EndPlayerTurn()

        if stackingCounter > 0 and (UI_EnableStacking or UI_EnableReverseSkipStacking) then
            showStackingCardPanelAndYield()

            if not playerIsStacking then
                DealCardsToColor(stackingCounter, currentPlayer.color)
                stackingCounter = 0
                EndPlayerTurn()
            else
                return
            end
        end
    --Check if the card played was a skip
    elseif lastCard_Name == "skip" then
        EndPlayerTurn()

        if stackingCounter > 0 and (UI_EnableStacking or UI_EnableReverseSkipStacking) then
            showStackingCardPanelAndYield()

            if not playerIsStacking then
                DealCardsToColor(stackingCounter, currentPlayer.color)
                stackingCounter = 0
                EndPlayerTurn()
            else
                return
            end
        else
            EndPlayerTurn()
        end
    --Check if the card played was a +2 card
    elseif lastCard_Name == "+2" then
        EndPlayerTurn()
        --Add To Our Stack Counter
        stackingCounter = stackingCounter + 2

        --Check if the game rules allow stacking +2 cards
        if UI_EnableStacking == true or UI_EnableD2Stacking == true then 
            showStackingCardPanelAndYield()
        end

        --If the player is not stacking, we deal the appropriate amount of cards, and skip their turn
        if playerIsStacking == false then
            DealCardsToColor(stackingCounter, currentPlayer.color)
            stackingCounter = 0

            EndPlayerTurn()
        else--If the player is stacking, we end the game loop and move onto the next player
            return
        end

    --Check if the card played was a wild card
    elseif lastCard_Desc == "WILD" then
        UI.show("WildCardPanel")
        UI.show("MessagePanel")
        UI.setAttribute("MessagePanelText", "Text", (Waiting_For_Wild_Card_Message):format(currentPlayer.steam_name))
        UI.setAttribute("WildCardPanel", "visibility", currentPlayer.color)

        ToggleDrawButtons(false)

        yieldState = YIELDSTATE.WILD
        coroutine.yield()
        EndPlayerTurn()

        if lastCard_Name == "+4" then
            --Add To Our Stack Counter
            stackingCounter = stackingCounter + 4

            if UI_EnableStacking == true or UI_EnableD4Stacking == true then
                showStackingCardPanelAndYield()
            end

            if playerIsStacking == false then
                --If the player is not stacking, we deal the appropriate amount of cards, and skip their turn
                DealCardsToColor(stackingCounter, currentPlayer.color)
                stackingCounter = 0

                EndPlayerTurn()
            else
                return
            end
        end
    elseif lastCard_Name == "7"
    then
        if UI_EnableSevenZero == true
        then
            UI.show("MessagePanel")
            UI.setAttribute("MessagePanelText", "Text", (Waiting_For_Trade_Message):format(currentPlayer.steam_name) )
            UI.setAttribute("HandSwappingPanel", "visibility", currentPlayer.color)
            ToggleDrawButtons(false)
            ToggleHandTradeButtons(true)

            yieldState = YIELDSTATE.TRADE
            coroutine.yield()

            ToggleHandTradeButtons(true)
        end
        EndPlayerTurn()
    elseif lastCard_Name == "0"
    then
        if UI_EnableSevenZero == true
        then
            broadcastToAll(currentPlayer.steam_name .. " is rotating the table's hands", {1,1,1} )
            RotateHands()
        end
        EndPlayerTurn()
    else
        EndPlayerTurn()
    end
    if show_UNO == true
    then
        PlayerHasUNO(currentPlayer.color)
    end
    yieldState = nil
end--function GameLoop END

function showStackingCardPanelAndYield()
    UI.show("StackingCardPanel")
    UI.show("MessagePanel")
    UI.setAttribute("MessagePanelText", "Text", (Waiting_For_Stacking_Message):format(currentPlayer.steam_name))
    UI.setAttribute("StackingCardPanel", "visibility", currentPlayer.color)
    ToggleDrawButtons(false)

    UI.setAttribute("StackingCardPanelText01", "Text", getStackOptionsString())
    UI.setAttribute("StackingCardPanelText02", "Text", stackingCounter)
    --we set playerIsStacking to true and yield out of the coroutine. If the player chooses to not stack
    --we will set playerIsStacking to false then. Otherwise when the player plays a card (which is set up to only accent another +2 at this point)
    --it will resume the coroutine at this point, and the playerIsStacking will still be true
    playerIsStacking = true
    yieldState = YIELDSTATE.STACK
    coroutine.yield()
end

function getStackOptionsString()
    availableStackOptions = {}
    if UI_EnableD2Stacking == true or UI_EnableStacking == true then
        table.insert(availableStackOptions, "+2")
    end
    if UI_EnableD4Stacking or UI_EnableStacking then
        table.insert(availableStackOptions, "+4")
    end
    if UI_EnableReverseSkipStacking or UI_EnableStacking then
        table.insert(availableStackOptions, "Reverse, Skip")
    end
    return Stack_On_Another_Card:format(table.concat(availableStackOptions, ", "))
end

---------------------------------------------------------------------------------------------------------------------------
--UI RELATED FUNCTIONS
---------------------------------------------------------------------------------------------------------------------------
--[[This function is called when the "Play with an additional deck" toggle is changed from the Main Menu]]
function CallAdditionalDeckRuleChange(n, value, ID)
    UI_EnableAdditionalDeck = value == "True"
end

--[[This function is called by the Play with Calling Uno Button toggle is changed from the Main Menu]]
function CallUnoRuleChange(n, value, ID)
    
    if value == "True"
    then
        UI_EnableCallingUno = true
    else
        UI_EnableCallingUno = false
    end
end--Function CallUnoRuleChange END
--[[This function is called when a player clicks the UNO button]]
function Player_Calling_UNO(player,b,button)
    --If uno_Called is set to true, do nothing because the button has already been pressed
    if uno_Called == true
    then
        return
    else
        uno_Called = true
        HideUNO()
        if player.color ~= color_Has_Uno
        then
            --If a player calls uno on someone else, we announce it to the table
            broadcastToAll( string.format("%s Called Uno On %s! %s Must Draw 2 Cards!",player.color,color_Has_Uno,color_Has_Uno), getColorValueFromPlayer(color_Has_Uno))
            --If a player clicks the UNO button that is not the one with UNO, we penalize them by giving them 2 cards
            DealCardsToColor(2,color_Has_Uno)
        else
            --We also broadcast that a player has UNO so that players are aware
            broadcastToAll( ("%s has UNO!"):format(player.color) ,player.color)
        end
    end
end--Function Player_Calling_UNO END
--[[This function is called by the 'Draw UNO Penalty Button' for use when playing without the 'Call Uno Button']]
function Draw_UNO_Penalty(player,b,button)
    DealCardsToColor(2,player.color)
    removeColorFromUNOTable(player.color)
    UI.setAttribute("UNO_Penalty_Button","visibility",getVisibilityTargerts(colorsWithUNO))
    if(#colorsWithUNO < 1)
    then
        UI.setAttribute("UNO_Penalty_Button","active","false")
    end
end--Function Draw_UNO_Penalty END
--[[This function is called when the "Don't Stack" button is click from the stacking card UI panel]]
function StackingPanelButtons()

    playerIsStacking = false
    coroutine.resume(gameloopCoroutine)

    UI.hide("StackingCardPanel")
    UI.hide("MessagePanel")
    ToggleDrawButtons(true)

end--Function StackingPanelButtons END
--[[This function is called by the buttons from the Wild Card UI panel]]
function WildPanelButtons(a,b, ID)
    if ID == "WildButtonRed"
    then
        lastCard_Desc = "RED"
    elseif ID == "WildButtonBlue"
    then
        lastCard_Desc = "BLUE"
    elseif ID == "WildButtonYellow"
    then
        lastCard_Desc = "YELLOW"
    elseif ID == "WildButtonGreen"
    then
        lastCard_Desc = "GREEN"
    end

    broadcastToAll("The Color Is Now ".. lastCard_Desc, getColorValueFromCard(lastCard_Desc))
    playMattObject.setColorTint(getColorValueFromCard(lastCard_Desc))
    rotationMattObject.setColorTint(getColorValueFromCard(lastCard_Desc))
    coroutine.resume(gameloopCoroutine)

    UI.hide("WildCardPanel")
    UI.hide("MessagePanel")
    ToggleDrawButtons(true)

end--Function WildPanelButtons END

--[[This function is called by the buttons from the Trade Hands UI panel]]
function HandTradeButtons(a,b,ID)
    local stringToPlayer = {
        Player_White = {player = Player.White, display = "White"},
        Player_Red = {player = Player.Red, display = "Red"},
        Player_Orange = {player = Player.Orange, display = "Orange"},
        Player_Yellow = {player = Player.Yellow, display = "Yellow"},
        Player_Green = {player = Player.Green, display = "Green"},
        Player_Blue = {player = Player.Blue, display = "Blue"},
        Player_Purple = {player = Player.Purple, display = "Purple"},
        Player_Pink = {player = Player.Pink, display = "Pink"},
    }

    if stringToPlayer[ID] then
        local playerInfo = stringToPlayer[ID]
        print(a.steam_name .. " wants to trade hands with " .. playerInfo.display)
        SwapHands(getIndexFromPlayer(a.color),getIndexFromPlayer(playerInfo.player.color))
        broadcastToAll("" .. a.steam_name .. " is trading their hand with " .. playerInfo.player.steam_name, {1,1,1})
    else
        print(a.steam_name .. " Doesn't Want To Trade Hands")
    end

    coroutine.resume(gameloopCoroutine)

    UI.setAttribute("HandSwappingPanel", "Active", "false")
    UI.hide("MessagePanel")
    ToggleDrawButtons(true)
end--Function HandTradeButtons END

--[[This function is used to show or hide the hand trading buttons]]
function ToggleHandTradeButtons(value)

    if value == true
    then
        UI.setAttribute("HandSwappingPanel", "active", "true")
        for i, _player in ipairs(PLAYERS_REF)
        do

            if _player == Player.White
            then
                if _player.seated == true
                then
                    UI.setAttribute("Player_White", "Interactable", "true")
                    UI.setAttribute("Player_White", "Text", _player.steam_name)

                    if _player == currentPlayer
                    then
                        UI.setAttribute("Player_White", "Interactable", "false")
                        UI.setAttribute("Player_White", "Text", "You")
                    end
                else
                    UI.setAttribute("Player_White", "Interactable", "false")
                    UI.setAttribute("Player_White", "Text", "Not Seated")
                end
            elseif _player == Player.Red
            then
                if _player.seated == true
                then
                    UI.setAttribute("Player_Red", "Interactable", "true")
                    UI.setAttribute("Player_Red", "Text", _player.steam_name)
                    if _player == currentPlayer
                    then
                        UI.setAttribute("Player_Red", "Interactable", "false")
                        UI.setAttribute("Player_Red", "Text", "You")
                    end
                else
                    UI.setAttribute("Player_Red", "Interactable", "false")
                    UI.setAttribute("Player_Red", "Text", "Not Seated")
                end
            elseif _player == Player.Orange
            then
                if _player.seated == true
                then
                    UI.setAttribute("Player_Orange", "Interactable", "true")
                    UI.setAttribute("Player_Orange", "Text", _player.steam_name)
                    if _player == currentPlayer
                    then
                        UI.setAttribute("Player_Orange", "Interactable", "false")
                        UI.setAttribute("Player_Orange", "Text", "You")
                    end
                else
                    UI.setAttribute("Player_Orange", "Interactable", "false")
                    UI.setAttribute("Player_Orange", "Text", "Not Seated")
                end
            elseif _player == Player.Yellow
            then
                if _player.seated == true
                then
                    UI.setAttribute("Player_Yellow", "Interactable", "true")
                    UI.setAttribute("Player_Yellow", "Text", _player.steam_name)
                    if _player == currentPlayer
                    then
                        UI.setAttribute("Player_Yellow", "Interactable", "false")
                        UI.setAttribute("Player_Yellow", "Text", "You")
                    end
                else
                    UI.setAttribute("Player_Yellow", "Interactable", "false")
                    UI.setAttribute("Player_Yellow", "Text", "Not Seated")
                end
            elseif _player == Player.Green
            then
                if _player.seated == true
                then
                    UI.setAttribute("Player_Green", "Interactable", "true")
                    UI.setAttribute("Player_Green", "Text", _player.steam_name)
                    if _player == currentPlayer
                    then
                        UI.setAttribute("Player_Green", "Interactable", "false")
                        UI.setAttribute("Player_Green", "Text", "You")
                    end
                else
                    UI.setAttribute("Player_Green", "Interactable", "false")
                    UI.setAttribute("Player_Green", "Text", "Not Seated")
                end
            elseif _player == Player.Blue
            then
                if _player.seated == true
                then
                    UI.setAttribute("Player_Blue", "Interactable", "true")
                    UI.setAttribute("Player_Blue", "Text", _player.steam_name)
                    if _player == currentPlayer
                    then
                        UI.setAttribute("Player_Blue", "Interactable", "false")
                        UI.setAttribute("Player_Blue", "Text", "You")
                    end
                else
                    UI.setAttribute("Player_Blue", "Interactable", "false")
                    UI.setAttribute("Player_Blue", "Text", "Not Seated")
                end
            elseif _player == Player.Purple
            then
                if _player.seated == true
                then
                    UI.setAttribute("Player_Purple", "Interactable", "true")
                    UI.setAttribute("Player_Purple", "Text", _player.steam_name)
                    if _player == currentPlayer
                    then
                        UI.setAttribute("Player_Purple", "Interactable", "false")
                        UI.setAttribute("Player_Purple", "Text", "You")
                    end
                else
                    UI.setAttribute("Player_Purple", "Interactable", "false")
                    UI.setAttribute("Player_Purple", "Text", "Not Seated")
                end
            elseif _player == Player.Pink
            then
                if _player.seated == true
                then
                    UI.setAttribute("Player_Pink", "Interactable", "true")
                    UI.setAttribute("Player_Pink", "Text", _player.steam_name)
                    if _player == currentPlayer
                    then
                        UI.setAttribute("Player_Pink", "Interactable", "false")
                        UI.setAttribute("Player_Pink", "Text", "You")
                    end
                else
                    UI.setAttribute("Player_Pink", "Interactable", "false")
                    UI.setAttribute("Player_Pink", "Text", "Not Seated")
                end
            end

        end
    elseif value == false
    then
        UI.setAttribute("HandSwappingPanel", "active", "false")
    end

end--Function ToggleHandTradeButtons END
--[[This function is used to show or hide the draw card buttons]]
function ToggleDrawButtons(value)
    if value == false
    then
        drawButtons[0].setScale({0,0,0})
        drawButtons[1].setScale({0,0,0})
    else
        drawButtons[0].setScale({0.5,0.5,0.5})
        drawButtons[1].setScale({0.5,0.5,0.5})
    end
end--Function ToggleDrawButtons END
--[[This function is called by the Hide/Show menu button and should be self explanatory]]
function ToggleStartMenu(value)

    if UI.getAttribute("StartGameMenu", "active") == "true"
    then
        UI.setAttribute("StartGameMenu", "active", "false")
        UI.setAttribute("MainMenuContainer", "color", "RGBA(0.105,0.157,0.22,0)")
        UI.setAttribute("MainMenuContainer", "height", "5%")
        UI.setAttribute("MainMenuContainer", "width", "15%")
        UI.setAttribute("HideMenuButton", "text", "Show Main Menu")
        UI.setAttribute("HideMenuButton", "height", "100%")

    else
        UI.setAttribute("StartGameMenu", "active", "true")
        UI.setAttribute("MainMenuContainer", "color", "RGBA(0.105,0.157,0.22,1)")
        UI.setAttribute("MainMenuContainer", "height", "90%")
        UI.setAttribute("MainMenuContainer", "width", "50%")
        UI.setAttribute("HideMenuButton", "text", "Hide Main Menu")
        UI.setAttribute("HideMenuButton", "height", "5%")
    end

end--Function ToggleStartMenu END
--[[This function is called by the Draw Deck Rule Toggle Butttons from the Main Menu]]
function CardDrawingRuleChange(n, value, id)

    if value == "True"
    then
        if id == "drawOneCard"
        then
            UI_DrawOneCard = true
            UI_AllowTurnPassing = false

            UI.setAttribute("TurnPassingText","color","black")
            UI.setAttribute("TurnPassingText2","color","black")
            UI.setAttribute("noPassing","textColor","black")
            UI.setAttribute("allowPassing","textColor","black")

            UI.setAttribute("noPassing","interactable","false")
            UI.setAttribute("noPassing","isOn","true")
            UI.setAttribute("allowPassing","interactable","false")

            UI.setAttribute("TurnPassingText2","text","Turn Passing is Disabled When Only Drawing One Card Per Turn")

        elseif id == "drawManyCards"
        then
            UI_DrawOneCard = false
            UI_AllowTurnPassing = false

            UI.setAttribute("TurnPassingText","color","white")
            UI.setAttribute("TurnPassingText2","color","gray")
            UI.setAttribute("noPassing","textColor","white")
            UI.setAttribute("allowPassing","textColor","white")

            UI.setAttribute("noPassing","interactable","true")
            UI.setAttribute("allowPassing","interactable","true")

            UI.setAttribute("TurnPassingText2","text","Don't Pass After Drawing Cards | Pass Turn After Drawing Cards")
        end
    end

end--Function CardDrawingRuleChange
--[[This function is called by the "Allow Turn Passing" buttons from the Main Menu]]
function TurnPassingRuleChange(n, value, id)

    if value == "True"
    then
        if id == "allowPassing"
        then
            UI_AllowTurnPassing = true
        elseif id == "noPassing"
        then
            UI_AllowTurnPassing = false
        end
    end

end--Function CardDrawingRuleChange
--[[This function is called by the Stacking Rule Toggle Buttons from the Main Menu]]
function StackingRuleChange(n , value, id)
    if id == "allStackToggle" then --If 'Stack +2 and +4 Cards' has been chosen
        UI_EnableStacking = value == "True"
    elseif id == "p2StackToggle" then --If 'Only Stack +2 Cards' has been chosen
        UI_EnableD2Stacking = value == "True"
    elseif id == "p4StackToggle" then --if 'Only Stack +4 Cards' has been chosen
        UI_EnableD4Stacking = value == "True"
    elseif id == "reverseSkipStackToggle" then
        UI_EnableReverseSkipStacking = value == "True"
    end
    
    if debugging == true then
        DebugFunction("Stacking "..tostring(UI_EnableStacking),"D2 "..tostring(UI_EnableD2Stacking),"D4 "..tostring(UI_EnableD4Stacking),"RS "..tostring(UI_EnableReverseSkipStacking))
    end
end--Function StackingRuleChange END
--[[This function is called by the 7-0 Rule Toggle Button from the Main Menu]]
function SevenZeroRuleChange(n, value, id)

    if value == "True"
    then
       UI_EnableSevenZero = true
    else
        UI_EnableSevenZero = false
    end
end--Function SevenZeroRuleChange END
--[[This function is called by the "Pick Player One" element from the Main Menu, and is used to pick the first player in order]]
function PickPlayerOne(obj,color)

    if color ~= "Black"
    then
        if playerOne_Index + 1 > #seatedPlayers
        then
            playerOne_Index = 1
        else
            playerOne_Index = playerOne_Index + 1
        end
        UI.setAttribute("playerOneButton", "text", seatedPlayers[playerOne_Index].steam_name )
        UI.setAttribute("playerOneButton", "color", seatedPlayers[playerOne_Index].color)
    end

end--Function PickPlayerOne END

---------------------------------------------------------------------------------------------------------------------------
--HELPER FUNCTIONS
---------------------------------------------------------------------------------------------------------------------------

function getVisibilityTargerts()
    tempString = "|"
    for i=1, #colorsWithUNO
    do
        tempString = tempString .. colorsWithUNO[i] .. "|"
    end
    return tempString

end
function removeColorFromUNOTable(color)
    for i=1,#colorsWithUNO
    do
        if colorsWithUNO[i] == color
        then
            table.remove( colorsWithUNO, i )
        end
    end
end

function getNextSeatedPlayerIndex(currentIndex)
    local newIndex = currentIndex + 1
    if newIndex > #seatedPlayers
    then
        newIndex = 1
    end
    return newIndex
end
--[[Helper Function to return the index a player color is in the 'seatedPlayers' table that keeps track of currently seated players]]
function getIndexFromPlayer(player_color)
    for i=1,#seatedPlayers
    do
        if seatedPlayers[i].color == player_color
        then
            return i
        end
    end
end--Function getIndexFromPlayer END
--[[Helper Function to return a color code give a PLAYERS_REF color string]]
function getColorValueFromPlayer (player_color)
    if player_color == "Green"
    then
        return {0.129,0.701,0.168}

    elseif player_color == "Blue"
    then
        return {0.118, 0.53, 1}

    elseif player_color == "Purple"
    then
        return {0.627, 0.125, 0.941}

    elseif player_color == "Pink"
    then
        return {0.96, 0.439, 0.807}

    elseif player_color == "White"
    then
        return {1, 1, 1}

    elseif player_color == "Red"
    then
        return {0.856, 0.1, 0.094}

    elseif player_color == "Orange"
    then
        return {0.956, 0.392, 0.113}

    elseif player_color == "Yellow"
    then
        return {0.905, 0.898, 0.172}

    elseif player_color == "Grey"
    then
        return {0.5, 0.5, 0.5}

    elseif player_color == "Black"
    then
        return {0.25, 0.25, 0.25}

    end

end--Function getColorValueFromPlayer END
--[[Helper Function to return a color code given a card color string]]
function getColorValueFromCard (card_color)

    if card_color == "GREEN"
    then
        return {0.129,0.701,0.168}
    end

    if card_color == "BLUE"
    then
        return {0.118, 0.53, 1}
    end

    if card_color == "RED"
    then
        return {0.856, 0.1, 0.094}
    end

    if card_color == "YELLOW"
    then
        return {0.905, 0.898, 0.172}
    end

end--Function getColorValueFromCard END
--[[Helper Function to return the apropriate TOKENPOSITION vector given a PLAYERS_REF color string]]
function getTokenLocation(color)

    if color == "Green"
    then
        return TOKENLOCATIONS_REF.GREEN
    elseif color == "Blue"
    then
        return TOKENLOCATIONS_REF.BLUE
    elseif color == "Purple"
    then
        return TOKENLOCATIONS_REF.PURPLE
    elseif color == "Pink"
    then
        return TOKENLOCATIONS_REF.PINK
    elseif color == "White"
    then
        return TOKENLOCATIONS_REF.WHITE
    elseif color == "Red"
    then
        return TOKENLOCATIONS_REF.RED
    elseif color == "Orange"
    then
        return TOKENLOCATIONS_REF.ORANGE
    elseif color == "Yellow"
    then
        return TOKENLOCATIONS_REF.YELLOW
    elseif color == "Black"
    then
        return TOKENLOCATIONS_REF.WHITE
    end

end--Function getTokenLocation END
--[[Helper Function to return the appropriate TOKENROATIONS vector given a PLAYERS_REF color string]]
function getTokenRotation(color)

    if color == "Green"
    then
        return TOKENROTATIONS_REF.GREEN
    elseif color == "Blue"
    then
        return TOKENROTATIONS_REF.BLUE
    elseif color == "Purple"
    then
        return TOKENROTATIONS_REF.PURPLE
    elseif color == "Pink"
    then
        return TOKENROTATIONS_REF.PINK
    elseif color == "White"
    then
        return TOKENROTATIONS_REF.WHITE
    elseif color == "Red"
    then
        return TOKENROTATIONS_REF.RED
    elseif color == "Orange"
    then
        return TOKENROTATIONS_REF.ORANGE
    elseif color == "Yellow"
    then
        return TOKENROTATIONS_REF.YELLOW
    elseif color == "Black"
    then
        return TOKENROTATIONS_REF.WHITE
    end

end--Function getTokenRotation END
--[[Helper Function to clamp the value between the min value and the max value]]
function ClampValue(value,min,max)
    if value < min
    then
        value = min
    end

    if value > max
    then
        value = max
    end

    return value
end--Function ClampValue END
--[[Debug function to print the arguments passed from the caller. Helpful to findout what information is passed from object events or callback functions]]
function DebugFunction(a, b, c, d, e)
    print("Debug Print: ", a , " | ", b ," | ", c, " | ", d, " | ", e)
end--Function DebugFunction END